1. 不在js中写css样式 ，不在js中拼接html  前者可以使用添加类来解决，后者可以使用模板引擎来解决，模板使用带有自定义type属性的script元素，浏览器会默认把script中的元素识别为js代码，但是可以通过给type赋值为浏览器不识别的类型，然后通过 script标签的text属性来提取
## 避免使用全局变量
坏处: 
- 命名冲突：

```
function sayHello(){
  alert(color)//并不知道color哪里来的
}
```
- 代码脆弱
如果全局变量color不再存在时，该函数不能运行，但是如果上面把color作为参数传入：维护性变好，任何来自函数外面的数据都应当以参数形式传递进来，这样可以使得函数与外部函数隔离开来 并且尽量将数据放在局部作用域内
- 难于测试， 代码需要全局变量
## 最佳实践：单变量全局模式 比如backbone的Backbone变量
命名空间：Backbone.Event;Backbone.Model
## 规则7 事件处理
- 规则1 ：将应用逻辑从所有事件处理程序中剥离出来 是最佳实践，因为可能其他地方也会触发同一段逻辑，如果写在里面，则相同代码会被复制多次，另外 有利于测试
- 不要分发事件对象
应用逻辑不应当依赖于event对象来完成功能：因为方法接口病没有表明那些数据是必要的，好的api对于期望和依赖都是明确的，如果想测试该方法，必须要重建一个event对象并把它作为参数传递，代码不够明确就会导致bug。
最好的方式是使用event来处理事件，然后拿到所有需要的数据传递给应用逻辑，![image](img/1.png) 
 ![image](img/2.png)
,然后可以在测试的时候直接调用代码：
```
 myApplation.showPops(39,10);
```
在处理事件时，最好让事件处理程序只接触到event对象下面的一些明确参数，比如x  y 而不要去进行阻止默认事件 等等，应该直接在包好事件处理程序中。
```
var my={

  handle_click:(event)=>{
    event.stopPropagation();
    
    this.show_pop(event.x,event.y);
  },
  show_pop:(x,y)=>{
  
  var popup=document.createElement('div');
  popup.style.x=x;
  
  }
}
```
这样可以使得应用逻辑不对event产生依赖，然后可以在很多地方编写测试用例
## 避免空比较

```
 if(item!==null || item !== undefined){
 //code here...
 }
```
## 检测数组
instanceof Array 在跨帧时不会返回正确的值，
但是可以通过鸭式来判断。
typeof arr.sort ==='function'
但是基于一个事实，数组是唯一包含sort方法的对象
最好的方式
```
 Object.prototype.toString.call(value)=="[Obejct Array]"
 或者 es5的
 Array.isArray()也可以跨帧检测数组
```
### 检测属性
使用in 或者hasownproperty
```
//bad
  if（object[propertyname]）{
  
  }
//bad
if（object[propertyname]!==null）{
  
  }
//bad
if（object[propertyname]!==undefined）{
  
  }
  因为当属性值为假值时会出错
  '' false,null,undefined,0
  
```
最好使用in来判断 他会简单地判断属性是否存在，而不会去读属性，原型也可以，
  如果只想检测实例属性的话，使用hasOwnProperty。
### 将数据从代码中分离出来作为配置

#### 什么是配置数据
经常变动的，还有比如类名之类的会在代码里面出现多次的，
url；
需要展现给用户的字符串
重复的zhi
设置
任何可能发送变更的值
时刻记住：配置数据是可以发送变更的

- 保存配置数据
配置数据最好放在单独的文件里面，方便清晰得分离数据和应用逻辑。

#### 抛出错误

```
function a(num){
  if(typeof num !='string'){
    throw new Error('不是字符串')
    }
}
```
何时抛出错误：私有函数不需要，需要提供给别人使用的需要
#### try catch
可以把容易出错的代码放在try里面，处理错误的代码放在catch里面    
如果有一个finally{}模块。那么不管是否有错误发生，最后都会被执行

```
function a(num){
try {
 // ab();
}catch(e){
  //执行错误处理
  console.log(e)
} finally {
   console.log('finally excuted')
}
}
```
### 不是你的对象不要动
在一个多人开发的项目中 动别人的对象会带来问题
比如 :原生对象，dom对象，bom， 不要去修改他们。
原则：可以将已经存在的对象视为一种背景，
不要覆盖方法，不新增方法，不删除方法
#### 不覆盖方法

### 文件和目录结构
#### 13.1 最佳实践
- 一个文件包含一个js对象的代码，
好处：该模式在其他编程语言中很常见并且容易维护，并且降低了多个开发者修改同一个文件的风险
- 相关的文件用目录分组：
如果你有多个相关联的对象，就把这些文件放在同一个目录下面，，有利于开发者更容易定位功能。
- 保持第三方代码的独立
任何不是你编写或者维护的代码，都应该独立于项目工程以外，最理想是不引入，直接从cdn加载，或者放在一个单独的目录里面。

#### 13.2大型网站基本结构
js目录下面放置3个主要的目录
  - build 
  最终构建后的 文件，理想情况下该目录不应该被提交
 - src
  放置所由的源文件，包括分组的子目录
 - test
 包含同源测试目录文件

### 附录js编码风格指南

- 缩进：
每一行的层级由4个空格组成，避免使用tab进行缩进
- 行的长度
每行长度不应该超过80个字符，如果超过，应当在一个运算符后面换行(,+)，下一行应当缩进8个字符
```

 dosomething(arg1,arg2,arg3,
        arg4,arg5)
```
- 原始值
字符串始终使用双引号，避免使用单引号，避免使用斜杠另起一行。
```
 var long = " Here are my \
 naned andy";
```
过长字符串解决方案:
```
var str=['f','f','辅导费'].join(' ')
```
特殊值 null应当尽量只在一下情况使用
1. 初始化一个变量，该对象可能是一个变量；
2. 当函数的参数期望是对象时，被作为参数传入
3. 函数的返回值期望是对象时，被用作返回值传出
避免使用undefined，判断使用typeof操作符
- 运算符间距
二元运算符前后使用空格来保持表达式的简洁，
```
var a = "name";
```
- 括号间距
当使用括号时，紧接左括号之后和右括号之前不应该有空格
```
var fond = (values[i] === item)
```
- 注释
以下应当使用注释：
代码晦涩难懂；可能被认为错误的代码；必要但并不明显针对特定浏览器的代码；对于对象，方法，属性，生成文档是有必要的
- - 单行注释：
- 使用方式：独占一行的注释，用来解释下一行的代码；在代码行的尾部的注释，解释它之前的代码；多行，注释掉一个代码块
- 多行注释：特征：首行以\/\*开头，不应当有其他文字，最后一行以\*\/结尾，不应当有文字
```
 if(condition){
 
  /*
  * 如果代码执行代理这里
  * 说明通过了安全检查
  *
  */
  
 }
 注释之前要有空行 *前面要有空格
```
- 注释声明
注释有时候可以给一段代码声明额外的信息，这些声明格式以单个单词打头病紧跟一个双引号。

单词| 作用 
---|--- 
TODO | 说明代码没有完成，应当包含下一步要做的事情 
HACK | 说明代码实现由捷径，应当包含为何使用hack的原因
XXX   | 说明代码是有问题的病应当尽快修复
FIXME | 有问题，重要性小于xxx
REVIEW | 说明代码任何可能改动的地方都需要评审
这些都应当包含在注释中

- 变量定义
所有变量在使用前都应当事先定义，变量定义应当放在函数之前
函数定义：应当在使用前面定义声明
```
function test(a,b) {
// code here
}

```